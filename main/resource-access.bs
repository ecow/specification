Authenticated Resource Access {#resource-access}
================================================

Issue: Write introduction to the Authenticated Resource Access section.

## Hypertext Transfer Protocol ## {#http}

### Background and Need ### {#http-need}
<em>This section is non-normative.</em>

Solid clients and servers need to exchange data securely over the Internet,
and they do so using the HTTP Web standard.
This section describes in detail
which parts of HTTP must be implemented by clients and servers.

### Required server-side implementation ### {#http-server}

A [=data pod=] MUST be an HTTP/1.1 server [[!RFC7230]][[!RFC7231]].
It SHOULD additionally be an HTTP/2 server [[!RFC7540]]
to improve performance,
especially in cases where individual clients
are expected to send high numbers of successive requests.

A data pod SHOULD use TLS connections
through the `https` URI scheme
in order to secure the communication between clients and servers.
When both `http` and `https` are supported,
all `http` URIs MUST redirect to their `https` counterparts
using a response with a `301` status code and a `Location` header.

A data pod MUST implement the server part
of <cite>HTTP/1.1 Conditional Requests</cite> [[!RFC7232]]
to ensure that updates requested by clients
will only be applied if given preconditions are met.
It SHOULD additionally implement the server part
of <cite>HTTP/1.1 Caching</cite> [[!RFC7234]]
to improve performance.
A data pod MAY implement the server part
of <cite>HTTP/1.1 Range Requests</cite> [[!RFC7233]]
to further improve performance for large representations.

A data pod MUST implement the server part
of <cite>HTTP/1.1 Authentication</cite> [[!RFC7235]].
When a client does not provide valid credentials
when requesting a resource that requires it (see [[#webid]]),
the data pod MUST send a response with a `401` status code
(unless `404` is preferred for security reasons).

A Solid server MUST reject `PUT`, `POST` and `PATCH` requests without the
`Content-Type` header with a status code of `400`.
[[Source](https://github.com/solid/specification/issues/70#issuecomment-535499628)]

### Required client-side implementation ### {#http-client}

A Solid client MUST be an HTTP/1.1 client [[!RFC7230]][[!RFC7231]].
It MAY additionally be an HTTP/2 client [[!RFC7540]]
to improve performance.

A Solid client MAY implement the client parts of
<cite>HTTP/1.1 Conditional Requests</cite> [[!RFC7232]]
to only trigger updates when certain preconditions are met.
It MAY implement
<cite>HTTP/1.1 Caching</cite> [[!RFC7234]]
and
<cite>HTTP/1.1 Range Requests</cite> [[!RFC7233]]
to improve performance.

A Solid client MUST implement the client part
of <cite>HTTP/1.1 Authentication</cite> [[!RFC7235]]
if it needs to access resources requiring authentication (see [[#webid]]).
When it receives a response with a `403` or `404` status code,
it MAY repeat the request with different credentials.

A Solid client MUST use the `Content-Type` HTTP header in `PUT`, `POST` and
`PATCH` requests [[!RFC7231]].
[[Source](https://github.com/solid/specification/issues/70#issuecomment-547924171)]

## Uniform Resource Identifier ## {#uri}

### Shared slash semantics ### {#uri-slash-semantics}

The slash character in the URI path indicates hierarchical relationship
segments, and enables relative referencing [[!RFC3986]]. The semantics of the
slash character is shared by servers and clients. Paths ending with a slash
denote a container resource.
[[Source](https://github.com/solid/specification/issues/35#issuecomment-547949014)]

If two URIs differ only in the trailing slash, and the server has associated a
resource with one of them, then the other URI MUST NOT correspond to another
resource. Instead, the server MAY respond to requests for the latter URI with
a 301 redirect to the former.
[[Source](https://github.com/solid/specification/issues/107#issuecomment-567482817)].
Behaviour pertaining to authorization MUST proceed this optional redirect
[[Source](https://github.com/solid/specification/issues/107#issuecomment-567454889)]

## Linked Data ## {#linked-data}

### Containment ### {#resource-containment}

Solid has the notion of containers to represent a collection of linked
resources to help with resource discovery and lifecycle management.

There is a 1-1 correspondence between containment triples and relative
reference within the path name hierarchy.
[[Source](https://github.com/solid/specification/issues/98#issuecomment-547506617)].
It follows that all resources are discoverable from a container and that it is
not possible to create orphan resources.
[[Source](https://github.com/solid/specification/issues/97#issuecomment-547459396)]

The representation and behaviour of containers in Solid corresponds to LDP
Basic Container and MUST be supported.
[[Source](https://github.com/solid/specification/issues/47#issuecomment-561675764)]

Server MUST create intermediate containers and include corresponding
containment triples in container representations derived from the URI path
component of `PUT`, `POST` and `PATCH` requests.
[[Source](https://github.com/solid/specification/issues/68#issuecomment-561690124)]

### Persistence ### {#uri-persistence}
<em>This section is non-normative.</em>

Servers should not re-use URIs, regardless of the mechanism by which resources
are created. Certain specific cases exist where URIs may be reinstated when it
identifies the same resource, but only when consistent with Web architecture's
<cite><a href="https://www.w3.org/TR/webarch/#URI-persistence">URI
persistence</a></cite> [[!WEBARCH]].
[[Source](https://github.com/solid/specification/issues/46#issuecomment-589619372)]

Note:
Servers that wish to disable URI re-use may want to use the `410` status
code.

### Resource type heuristics ### {#resource-type-heuristics}

Servers MUST apply the following heuristics to determine a request's resource
type
[[Source](https://github.com/solid/specification/issues/128#issuecomment-573033297)].

<table id="heuristics-resource-type">
  <caption>Heuristics to determine a resource type</caption>
  <thead>
    <tr>
      <th>`Slug`</th>
      <th>`Link`</th>
      <th>Result</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>`foo/`</td>
      <td>No `Link` header.</td>
      <td>Create a container with `foo/` appended to the request-URI.</td>
    </tr>
    <tr>
      <td><code>foo/</code></td>
      <td>`Link` header with `ldp:Container` or a specialisation.</td>
      <td>Create a container with `foo/` appended to the request-URI.</td>
    </tr>
    <tr>
      <td><code>foo/</code></td>
      <td>`Link` header other than container type.</td>
      <td>Create a resource with `foo` appended to the request-URI, check for
      consistency.</td>
    </tr>
    <tr>
      <td>`foo`</td>
      <td>No `Link` header.</td>
      <td>Create a resource with `foo` appended to the request-URI, check for
      consistency.</td>
    </tr>
    <tr>
      <td>`foo`</td>
      <td>`Link` header with `ldp:Container` or a specialisation.</td>
      <td>Create a container with `foo/` appended to the request-URI.</td>
    </tr>
    <tr>
      <td>`foo`</td>
      <td>`Link` header other than container type.</td>
      <td>Create a resource with `foo` appended to the request-URI, check for
      consistency.</td>
    </tr>
    <tr>
      <td><em>none</em></td>
      <td>No `Link` header.</td>
      <td>Create a resource with server determined identifier appended to the
      request-URI, check for consistency.</td>
    </tr>
    <tr>
      <td><em>none</em></td>
      <td>`Link` header with `ldp:Container` or a specialisation.</td>
      <td>Create a container with server determined identifier appended to the
      request-URI.</td>
    </tr>
    <tr>
      <td><em>none</em></td>
      <td>`Link` header other than container type.</td>
      <td>Create a resource with server determined identifier appended to the
      request-URI, check for consistency.</td>
    </tr>
  </tbody>
  <tfoot>
    <tr>
      <td colspan="3">
The consistency of a request is determined by checking its data, metadata and
URI
[[Source](https://github.com/solid/specification/issues/40#issuecomment-566995240)].
      </td>
    </tr>
  </tfoot>
</table>

## WebID ## {#webid}

Issue: Explain inline that agents accessing non-public Solid resources
  need to authenticate with a WebID, which is a URL
  pointing to a document with an RDF representation.


### WebID-OIDC ### {#webid-oidc}

Issue: Write WebID-OIDC section.

Draft:
A Solid data pod MUST conform to the WebID-OIDC specification [[!WEBID-OIDC]].


### WebID-TLS ### {#webid-tls}

Issue: Write WebID-TLS section.

Draft:
A Solid data pod MAY conform to the WebID-TLS specification [[!WEBID-TLS]].


## Web Access Control ## {#wac}

Issue: Write Web Access Control section.

Draft:
A Solid data pod MUST conform to the Web Access Control specification [[!WAC]].

A resource can advertise an ACL document that is directly associated by using
the HTTP `Link` header with a `rel` value of `acl`.
[[Source](https://github.com/solid/specification/issues/31#issuecomment-548360553)]

In the event that a server can't apply an ACL to a resource, it MUST deny
access.
[[Source](https://github.com/solid/specification/issues/130#issue-532777017)]

## Cross-Origin Resource Sharing ## {#cors}

### Background and Need ### {#cors-need}
<em>This section is non-normative.</em>

[=Solid apps=] typically access data from multiple sources.
However,
Web browsers by default prevent apps that run on one origin
from accessing data on other origins.
This cross-origin protection is a security mechanism
that ensures malicious websites cannot simply read
your profile or banking details from other websites.
However, this reasonable default poses a problem
even for benevolent Solid apps,
which might have good reasons to access data from different places.
For instance,
a Solid app at `https://app.example/`
would be prevented from accessing data on
`https://alice-data-pod.example/` or `https://bob-data-pod.example/`,
even when Alice and Bob have given the user of the app
their permission to see some of their data.

For cases where the other origins
have their own access protection mechanism—
[like within Solid](#wac)—
the browser's built-in cross-origin protection
is actually an obstacle rather than a feature.
After all,
[=data pods=] already ensure through access control
that certain documents can only be accessed
by specific people or applications.
Preventively blocking apps from different origins
thus introduces an unnecessary barrier.

Fortunately,
Web servers can indicate to the browser
that certain documents do not require cross-origin protection.
This mechanism to selectively disable that protection
is called *Cross-Origin Resource Sharing* or *CORS* [[FETCH]].
By responding to browser requests
with a specific combination of HTTP headers,
servers can indicate which actions are allowed for a given resource.
For a Solid data pod,
the goal is to allow *all* actions on the CORS level,
such that the deeper [access control layer](#wac)
can exert full control over the app's allowed permissions.
The next section describes how to achieve this
through the right HTTP header configuration.


### Required server-side implementation ### {#cors-server}

A [=data pod=] MUST implement the CORS protocol [[!FETCH]]
such that, to the extent possible,
the browser allows Solid apps
to send any request and combination of request headers
to the data pod,
and the Solid app can read any response and response headers
received from the data pod.
If the data pod wishes to block access to a resource,
this MUST NOT happen via CORS
but MUST instead be communicated to the Solid app in the browser
through HTTP status codes such as
`401`, `403`, or `404` [[!RFC7231]].

Note: Since the CORS protocol is part of a Living Standard,
it might be changed at any point,
which might necessitate changes to data pod implementations
for continued prevention of undesired blocking.
A [proposal](https://github.com/whatwg/fetch/issues/878) to mitigate this
has been suggested.

Concretely,
whenever a data pod receives an HTTP request
containing a valid `Origin` header [[!RFC6454]],
the server MUST respond with the appropriate `Access-Control-*` headers
as specified in the CORS protocol [[!FETCH]].
In particular,
the data pod MUST set the `Access-Control-Allow-Origin` header
to the valid `Origin` value from the request
and list `Origin` in the `Vary` header value.
The data pod MUST make all used response headers readable for the Solid app
through `Access-Control-Expose-Headers`
(with the possible exception of the `Access-Control-*` headers themselves).
A data pod MUST also support the HTTP `OPTIONS` method [[!RFC7231]]
such that it can respond appropriately to CORS preflight requests.

Careful attention is warranted,
especially because of the many edge cases.
For instance,
data pods SHOULD explicitly enumerate
all used response headers under `Access-Control-Expose-Headers`
rather than resorting to `*`,
which does not cover all cases (such as credentials mode set to `include`).
Data pods SHOULD also explicitly list `Accept` under `Access-Control-Allow-Headers`,
because values longer than 128 characters
(not uncommon for RDF-based Solid apps)
would otherwise be blocked,
despite shorter `Accept` headers being allowed without explicit mention.
